@startuml Diagrama Clases Banco

class Banco {
    + Banco()
    + sumarRecurso(recurso: Recurso, cantidad: int): void
    + descartarRecurso(recurso: Recurso, cantidad: int): void
    + tieneAlMenos(recurso: Recurso, cantidad: int): boolean
    + jugadorLeSolicitaRecurso(jugador: Jugador, recurso: Recurso, cantidad: int): void
    + jugadorQuiereIntercambiar(jugador: Jugador, recursoOfrecido: Recurso, cantidad: int, recursoDeseado: Recurso): void
    + obtenerRecurso(nombre: String): Recurso
    + sumarVariosRecursos(recursosQueRecibe: List<Recurso>): void
    + jugadorSolicitaDesarrollo(jugador: Jugador): void
    + getMadera(): Recurso
    + getLadrillo(): Recurso
    + getPiedra(): Recurso
    + getOveja(): Recurso
    + getTrigo(): Recurso
}

class MazoDesarrolloGeneral{
    + generarMazoDesarrolloBanco(): MazoDesarrolloGeneral
    + MazoDesarrolloGeneral()
    + mazoCaballeros(): List<CartaDesarrollo>
    + mazoPuntosDeVictoria(): List<CartaDesarrollo>
    + mazoDescubrimiento(): List<CartaDesarrollo>
    + mazoConstruccionCarreteras(): List<CartaDesarrollo>
    + mazoMonopolio(): List<CartaDesarrollo>
    + jugadorSolicitaDesarrollo(): CartaDesarrollo
}

abstract class CartaDesarrollo{
    + CartaDesarrollo()
    # prepararActivacion(): ActivacionDesarrollo
    + pasarTurnoDeCompra(): void
    + setEstado(estado: EstadoCartaDesarrollo): void
    + intentarActivarse(): ActivacionDesarrollo
    + modificarPuntaje(puntaje: int): int
    + jugadorMePuedePagar(jugador: Jugador): boolean
    + cobrarleAJugador(jugador: Jugador): void
    + sumarActivable(cartas: List<CartaDesarrollo>): List<CartaDesarrollo>
    + sumarUsada(cartas: List<CartaDesarrollo>): List<CartaDesarrollo>
    + sumarRecienComprada(cartas: List<CartaDesarrollo>): List<CartaDesarrollo>
}

class Recurso{
    + Recurso(cantidad: int)
    + Recurso()
    + crearMazoProduccionBanco(): Map<String, Recurso>
    + crearMazoProduccionJugador(): Map<String, Recurso>
    + getCantidad(): int
    + descartar(cantidad: int): void
    + sumar(cantidad: int): void
    + sumadorCantidad(cantidad: int): int
    + comerciarConBanco(jugador: Jugador, cantidad: int, recursoDeseado: Recurso, banco: Banco): void
    + cambiarRegla(reglaDeComercio: ReglaDeComercio): void
    + equals(o: Object): boolean
    + obtenerRecursoDeJugador(jugador: Jugador): Recurso
    + obtenerRecursoDeBanco(banco: Banco): Recurso
    + sumarCantidadDeUnRecursoAJugador(jugador: Jugador, cantidad: int): void
    + descartarCantidadDeUnRecursoAJugador(jugador: Jugador, cantidad: int): void
    + verificarSiJugadorTieneAlMenosUnaCantidadDeUnRecurso(jugador: Jugador, cantidad: int): boolean
    + sumarCantidadDeUnRecursoABanco(banco: Banco, cantidad: int): void
    + descartarCantidadDeUnRecursoABanco(banco: Banco, cantidad: int): void
    + verificarSiBancoTieneAlMenosUnaCantidadDeUnRecurso(banco: Banco, cantidad: int): boolean
    + cambiarReglaDeComercioDeUnJugador(jugador: Jugador, reglaDeComercio: ReglaDeComercio): void
    + comerciarRecursoDeUnJugadorConElBanco(jugador: Jugador, cantidad: int, recursoDeseado: Recurso, banco: Banco): void
    # transferirAlBanco(banco: Banco, cantidad: int): void
    # transferirAJugador(jugador: Jugador, cantidad: int): void
    # descartarAlBanco(banco: Banco, cantidad: int): void
    # descartarAJugador(jugador: Jugador, cantidad: int): void
    # hacerQuejugadorSoliciteABanco(jugador: Jugador, cantidad: int): void
    # getRecursoJugador(jugador: Jugador): Recurso
    # getRecursoBanco(banco: Banco): Recurso
    # jugadorTieneAlMenos(jugador: Jugador, cantidad: int): boolean
    # bancoTieneAlMenos(banco: Banco, cantidad: int): boolean
    # darReglaA(jugador: Jugador, reglaDeComercio: ReglaDeComercio): void
    # tieneAlMenos(cantidad: int): boolean
}

Banco-->MazoDesarrolloGeneral
MazoDesarrolloGeneral-->"*" CartaDesarrollo
Banco--> "*" Recurso
Recurso<|-- Madera
Recurso<|-- Ladrillo
Recurso<|-- Piedra
Recurso<|-- Oveja
Recurso<|-- Trigo
Banco..>Jugador


@enduml